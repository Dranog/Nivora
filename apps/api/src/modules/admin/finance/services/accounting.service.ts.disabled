// apps/api/src/modules/admin/finance/services/accounting.service.ts

import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { Prisma, ReconciliationStatus } from '@prisma/client';
import { PrismaService } from '../../../../common/prisma/prisma.service';
import { S3Service } from '../../../integrations/storage/s3.service';
import { ModerationGateway } from '../../gateways/moderation.gateway';
import { AuditService } from '../../../../common/audit/audit.service';
import { ExportGeneratorService } from '../../services/export-generator.service';
import { randomUUID } from 'crypto';
import {
  GetAccountingSummaryDto,
  ExportAccountingDto,
  GenerateReportDto,
  RevenueReportDto,
  PayoutsReportDto,
  ReconciliationQuery,
  ReconciliationListResponseDto,
  UpdateReconciliationDto,
} from '../dto/accounting.dto';

@Injectable()
export class AccountingService {
  private readonly logger = new Logger(AccountingService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly s3: S3Service,
    private readonly moderationGateway: ModerationGateway,
    private readonly audit: AuditService,
    private readonly exportGenerator: ExportGeneratorService,
  ) {}

  async getSummary(query: GetAccountingSummaryDto) {
    try {
      const { period, year, month } = query;
      const dateRange = this.calculateDateRange(period, year, month);

      const [revenue, fees, payouts, operatingCosts] = await Promise.all([
        this.calculateRevenue(dateRange),
        this.calculateFees(dateRange),
        this.calculatePayouts(dateRange),
        this.calculateOperatingCosts(dateRange),
      ]);

      const platformTakeRate = 0.15;
      const commission = Math.round(revenue * platformTakeRate);
      const netProfit = revenue - fees - commission - operatingCosts;

      const breakdown = await this.getRevenueBreakdown(dateRange);

      this.logger.log(`Generated accounting summary for ${period} ${year}${month ? `-${month}` : ''}`);

      return {
        revenue,
        fees,
        commission,
        netProfit,
        breakdown,
        period,
        year,
        month,
        dateRange: {
          start: dateRange.start.toISOString(),
          end: dateRange.end.toISOString(),
        },
      };
    } catch (error) {
      this.logger.error('Error generating accounting summary', error);
      throw error;
    }
  }

  async exportData(dto: ExportAccountingDto, adminId: string) {
    try {
      const exportId = randomUUID();

      const exportRecord = await this.prisma.exportHistory.create({
        data: {
          id: exportId,
          type: dto.type as any,
          format: dto.format as any,
          initiatedById: adminId,
          status: 'PROCESSING',
          filters: dto,
        },
      });

      this.processExport(exportRecord, adminId).catch((error) => {
        this.logger.error('Export processing failed', error);
      });

      this.logger.log(`Export ${exportId} initiated by admin ${adminId}`);

      return { exportId, status: 'PROCESSING' };
    } catch (error) {
      this.logger.error('Error initiating export', error);
      throw error;
    }
  }

  async getExportHistory(cursor?: string, limit: number = 50) {
    try {
      const exports = await this.prisma.exportHistory.findMany({
        where: {
          status: { in: ['PROCESSING', 'COMPLETED'] },
          expiresAt: { gt: new Date() },
        },
        take: limit + 1,
        ...(cursor ? { cursor: { id: cursor }, skip: 1 } : {}),
        orderBy: { createdAt: 'desc' },
        include: {
          initiatedBy: {
            select: {
              id: true,
              username: true,
              email: true,
              avatar: true,
            },
          },
        },
      });

      const hasMore = exports.length > limit;
      const items = hasMore ? exports.slice(0, -1) : exports;
      const nextCursor = hasMore ? items[items.length - 1].id : null;

      return { items, nextCursor, hasMore };
    } catch (error) {
      this.logger.error('Error fetching export history', error);
      throw error;
    }
  }

  async getExportById(exportId: string) {
    try {
      const exportRecord = await this.prisma.exportHistory.findUnique({
        where: { id: exportId },
        include: {
          initiatedBy: {
            select: {
              username: true,
              email: true,
            },
          },
        },
      });

      if (!exportRecord) {
        throw new NotFoundException('Export not found');
      }

      if (!exportRecord.fileUrl) {
        throw new NotFoundException('Export file not available yet');
      }

      return exportRecord;
    } catch (error) {
      this.logger.error('Error fetching export', error);
      throw error;
    }
  }

  // ============================================================================
  // REPORTS - Migrated from V1
  // ============================================================================

  async generateRevenueReport(dto: GenerateReportDto): Promise<RevenueReportDto> {
    const startDate = new Date(dto.startDate);
    const endDate = new Date(dto.endDate);

    const where: Prisma.TransactionWhereInput = {
      createdAt: { gte: startDate, lte: endDate },
      status: 'COMPLETED',
    };
    if (dto.filters?.userId) where.userId = dto.filters.userId;
    if (dto.filters?.authorId) where.creatorId = dto.filters.authorId;

    const [transactions, totalCount, totalSum] = await Promise.all([
      this.prisma.transaction.findMany({
        where,
        select: {
          type: true,
          amount: true,
          processingFee: true,
          paymentMethod: true,
          createdAt: true,
          creator: { select: { id: true, username: true } },
        },
      }),
      this.prisma.transaction.count({ where }),
      this.prisma.transaction.aggregate({
        where,
        _sum: { amount: true, processingFee: true },
      }),
    ]);

    const totalRevenue = totalSum._sum?.amount ?? 0;
    const totalFees = totalSum._sum?.processingFee ?? 0;
    const netRevenue = totalRevenue - totalFees;

    const typeMap = new Map<string, { count: number; amount: number }>();
    const methodMap = new Map<string, { count: number; amount: number }>();
    const creatorMap = new Map<string, { username: string; revenue: number; count: number }>();

    for (const tx of transactions) {
      const td = typeMap.get(tx.type) ?? { count: 0, amount: 0 };
      td.count++;
      td.amount += tx.amount;
      typeMap.set(tx.type, td);

      if (tx.paymentMethod) {
        const md = methodMap.get(tx.paymentMethod) ?? { count: 0, amount: 0 };
        md.count++;
        md.amount += tx.amount;
        methodMap.set(tx.paymentMethod, md);
      }

      if (tx.creator) {
        const cd = creatorMap.get(tx.creator.id) ?? {
          username: tx.creator.username,
          revenue: 0,
          count: 0,
        };
        cd.revenue += tx.amount;
        cd.count++;
        creatorMap.set(tx.creator.id, cd);
      }
    }

    const dailyMap = new Map<string, { transactions: number; revenue: number }>();
    for (const tx of transactions) {
      const day = tx.createdAt.toISOString().split('T')[0];
      const d = dailyMap.get(day) ?? { transactions: 0, revenue: 0 };
      d.transactions++;
      d.revenue += tx.amount;
      dailyMap.set(day, d);
    }

    const topCreators = Array.from(creatorMap.entries())
      .map(([id, d]) => ({
        authorId: id,
        username: d.username,
        revenue: d.revenue,
        transactionCount: d.count,
      }))
      .sort((a, b) => b.revenue - a.revenue)
      .slice(0, 10);

    return {
      period: { start: startDate.toISOString(), end: endDate.toISOString() },
      summary: {
        totalRevenue,
        totalTransactions: totalCount,
        totalFees,
        netRevenue,
        averageTransactionAmount: totalCount > 0 ? totalRevenue / totalCount : 0,
      },
      breakdown: {
        byType: Array.from(typeMap.entries()).map(([type, d]) => ({ type, count: d.count, amount: d.amount })),
        byPaymentMethod: Array.from(methodMap.entries()).map(([method, d]) => ({ method, count: d.count, amount: d.amount })),
        daily: Array.from(dailyMap.entries()).map(([date, d]) => ({ date, transactions: d.transactions, revenue: d.revenue })),
      },
      topCreators,
    };
  }

  async generatePayoutsReport(dto: GenerateReportDto): Promise<PayoutsReportDto> {
    const startDate = new Date(dto.startDate);
    const endDate = new Date(dto.endDate);

    const where: Prisma.PayoutWhereInput = { createdAt: { gte: startDate, lte: endDate } };

    const [payouts, statusCounts] = await Promise.all([
      this.prisma.payout.findMany({
        where,
        select: {
          id: true,
          amount: true,
          status: true,
          creator: { select: { id: true, username: true } },
        },
      }),
      this.prisma.payout.groupBy({
        by: ['status'],
        where,
        _count: true,
        _sum: { amount: true },
      }),
    ]);

    const totalPayouts = payouts.reduce((acc, p) => acc + p.amount, 0);
    const pendingPayouts = statusCounts.find((s) => s.status === 'PENDING')?._sum?.amount ?? 0;
    const completedPayouts = statusCounts.find((s) => s.status === 'COMPLETED')?._sum?.amount ?? 0;
    const failedPayouts = statusCounts.find((s) => s.status === 'FAILED')?._sum?.amount ?? 0;

    const creatorMap = new Map<string, { username: string; totalPaid: number; count: number }>();
    for (const p of payouts) {
      const d = creatorMap.get(p.creator.id) ?? { username: p.creator.username, totalPaid: 0, count: 0 };
      d.totalPaid += p.amount;
      d.count++;
      creatorMap.set(p.creator.id, d);
    }

    return {
      period: { start: startDate.toISOString(), end: endDate.toISOString() },
      summary: {
        totalPayouts,
        payoutCount: payouts.length,
        pendingPayouts,
        completedPayouts,
        failedPayouts,
      },
      breakdown: {
        byStatus: statusCounts.map((s) => ({ status: s.status, count: s._count, amount: s._sum?.amount ?? 0 })),
        byCreator: Array.from(creatorMap.entries())
          .map(([id, d]) => ({ authorId: id, username: d.username, totalPaid: d.totalPaid, payoutCount: d.count }))
          .sort((a, b) => b.totalPaid - a.totalPaid)
          .slice(0, 20),
      },
    };
  }

  // ============================================================================
  // RECONCILIATION - Migrated from V1
  // ============================================================================

  async getReconciliationRecords(query: ReconciliationQuery): Promise<ReconciliationListResponseDto> {
    const { page, limit, status, startDate, endDate, sortBy, sortOrder } = query;

    const where: Prisma.ReconciliationWhereInput = {};
    if (status) where.status = status as ReconciliationStatus;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }

    const total = await this.prisma.reconciliation.count({ where });
    const skip = (page - 1) * limit;
    const totalPages = Math.max(1, Math.ceil(total / limit));
    const orderBy: Prisma.ReconciliationOrderByWithRelationInput =
      sortBy ? ({ [sortBy]: sortOrder } as Prisma.ReconciliationOrderByWithRelationInput) : { createdAt: 'desc' };

    const rows = await this.prisma.reconciliation.findMany({ where, orderBy, skip, take: limit });

    const items = rows.map((r) => ({
      id: r.id,
      transactionId: r.transactionIds?.[0] ?? 'n/a',
      externalReference: r.type,
      amount: r.actualAmount,
      status: r.status,
      reconciliationDate: r.completedAt ? r.completedAt.toISOString() : null,
      notes: r.notes ?? null,
      createdAt: r.createdAt.toISOString(),
      updatedAt: r.updatedAt.toISOString(),
    }));

    return { items, total, page, limit, totalPages };
  }

  async updateReconciliation(recordId: string, data: UpdateReconciliationDto, adminId: string): Promise<void> {
    const newStatus = data.status;
    const isCompleted = newStatus === 'COMPLETED';

    await this.prisma.reconciliation.update({
      where: { id: recordId },
      data: {
        status: newStatus,
        notes: data.notes,
        completedAt: isCompleted ? new Date() : null,
      },
    });

    await this.audit.log({
      userId: adminId,
      event: 'ADMIN_UPDATE_RECONCILIATION',
      resource: 'RECONCILIATION',
      meta: data,
    });
  }

  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================

  private async processExport(exportRecord: any, adminId: string) {
    try {
      this.logger.log(`Processing export ${exportRecord.id} - Type: ${exportRecord.type}, Format: ${exportRecord.format}`);

      let data: any;

      if (exportRecord.type === 'accounting') {
        data = await this.getAccountingData(exportRecord.filters);
      } else if (exportRecord.type === 'transactions') {
        data = await this.getTransactionsData(exportRecord.filters);
      } else if (exportRecord.type === 'payouts') {
        data = await this.getPayoutsData(exportRecord.filters);
      }

      let fileBuffer: Buffer;
      let contentType: string;

      if (exportRecord.format === 'csv') {
        fileBuffer = await this.exportGenerator.generateCSV(data);
        contentType = 'text/csv';
      } else if (exportRecord.format === 'pdf') {
        fileBuffer = await this.exportGenerator.generatePDF(data, exportRecord.type);
        contentType = 'application/pdf';
      } else if (exportRecord.format === 'xlsx') {
        fileBuffer = await this.exportGenerator.generateXLSX(data);
        contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
      } else {
        throw new Error('Invalid format');
      }

      const fileKey = `exports/${exportRecord.id}.${exportRecord.format}`;
      await this.s3.upload(fileKey, fileBuffer, contentType);

      const fileUrl = await this.s3.getSignedUrl(fileKey, 7 * 24 * 60 * 60);

      const rowCount = data.items?.length || 0;

      await this.prisma.exportHistory.update({
        where: { id: exportRecord.id },
        data: {
          status: 'COMPLETED',
          fileUrl,
          fileKey,
          fileSize: fileBuffer.length,
          rowCount,
          completedAt: new Date(),
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        },
      });

      this.moderationGateway.emitExportComplete(exportRecord.id, adminId, {
        type: exportRecord.type,
        format: exportRecord.format,
        fileUrl,
        fileSize: fileBuffer.length,
        rowCount,
      });

      this.logger.log(`Export ${exportRecord.id} completed successfully`);
    } catch (error) {
      this.logger.error(`Export ${exportRecord.id} failed`, error);

      await this.prisma.exportHistory.update({
        where: { id: exportRecord.id },
        data: {
          status: 'FAILED',
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
        },
      });
    }
  }

  private calculateDateRange(period: string, year: number, month?: number) {
    let start: Date;
    let end: Date;

    switch (period) {
      case 'day':
        start = new Date(year, month ? month - 1 : 0, 1);
        end = new Date(year, month ? month - 1 : 0, 1, 23, 59, 59);
        break;
      case 'week':
        start = new Date(year, month ? month - 1 : 0, 1);
        end = new Date(start.getTime() + 7 * 24 * 60 * 60 * 1000);
        break;
      case 'month':
        start = new Date(year, month ? month - 1 : 0, 1);
        end = new Date(year, month ? month : 12, 0, 23, 59, 59);
        break;
      case 'year':
        start = new Date(year, 0, 1);
        end = new Date(year, 11, 31, 23, 59, 59);
        break;
      default:
        start = new Date(year, 0, 1);
        end = new Date(year, 11, 31, 23, 59, 59);
    }

    return { start, end };
  }

  private async calculateRevenue(dateRange: any) {
    const result = await this.prisma.payment.aggregate({
      where: {
        status: 'SUCCESS',
        type: { in: ['SUBSCRIPTION', 'PPV', 'TIP', 'PURCHASE'] },
        createdAt: { gte: dateRange.start, lte: dateRange.end },
      },
      _sum: { amount: true },
    });
    return result._sum.amount || 0;
  }

  private async calculateFees(dateRange: any) {
    const result = await this.prisma.payment.aggregate({
      where: {
        status: 'SUCCESS',
        createdAt: { gte: dateRange.start, lte: dateRange.end },
      },
      _sum: { processingFee: true },
    });
    return result._sum.processingFee || 0;
  }

  private async calculatePayouts(dateRange: any) {
    const result = await this.prisma.payout.aggregate({
      where: {
        status: 'COMPLETED',
        completedAt: { gte: dateRange.start, lte: dateRange.end },
      },
      _sum: { amount: true },
    });
    return result._sum.amount || 0;
  }

  private async calculateOperatingCosts(dateRange: any) {
    return 0;
  }

  private async getRevenueBreakdown(dateRange: any) {
    const [subscriptions, ppv, tips, marketplace] = await Promise.all([
      this.prisma.payment.aggregate({
        where: {
          type: 'SUBSCRIPTION',
          status: 'SUCCESS',
          createdAt: { gte: dateRange.start, lte: dateRange.end },
        },
        _sum: { amount: true },
      }),
      this.prisma.payment.aggregate({
        where: {
          type: 'PPV',
          status: 'SUCCESS',
          createdAt: { gte: dateRange.start, lte: dateRange.end },
        },
        _sum: { amount: true },
      }),
      this.prisma.payment.aggregate({
        where: {
          type: 'TIP',
          status: 'SUCCESS',
          createdAt: { gte: dateRange.start, lte: dateRange.end },
        },
        _sum: { amount: true },
      }),
      this.prisma.payment.aggregate({
        where: {
          type: 'MARKETPLACE',
          status: 'SUCCESS',
          createdAt: { gte: dateRange.start, lte: dateRange.end },
        },
        _sum: { amount: true },
      }),
    ]);

    return {
      subscriptions: subscriptions._sum.amount || 0,
      ppv: ppv._sum.amount || 0,
      tips: tips._sum.amount || 0,
      marketplace: marketplace._sum.amount || 0,
    };
  }

  private async getAccountingData(filters: any) {
    const dateFrom = new Date(filters.dateFrom);
    const dateTo = new Date(filters.dateTo);

    const [payments, payouts, summary] = await Promise.all([
      this.prisma.payment.findMany({
        where: {
          status: 'SUCCESS',
          createdAt: { gte: dateFrom, lte: dateTo },
        },
        select: {
          id: true,
          amount: true,
          type: true,
          status: true,
          createdAt: true,
          user: { select: { username: true, email: true } },
        },
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.payout.findMany({
        where: {
          status: 'COMPLETED',
          completedAt: { gte: dateFrom, lte: dateTo },
        },
      }),
      this.getSummary({
        period: 'month',
        year: dateFrom.getFullYear(),
        month: dateFrom.getMonth() + 1,
      }),
    ]);

    return {
      summary: {
        totalRevenue: summary.revenue,
        platformFees: summary.fees,
        commission: summary.commission,
        netProfit: summary.netProfit,
      },
      items: payments.map((p) => ({
        id: p.id,
        date: p.createdAt.toISOString(),
        type: p.type,
        username: p.user.username,
        amount: p.amount,
        status: p.status,
      })),
    };
  }

  private async getTransactionsData(filters: any) {
    const transactions = await this.prisma.payment.findMany({
      where: {
        createdAt: {
          gte: new Date(filters.dateFrom),
          lte: new Date(filters.dateTo),
        },
      },
      include: {
        user: { select: { id: true, username: true, email: true } },
      },
      orderBy: { createdAt: 'desc' },
    });

    return {
      items: transactions.map((t) => ({
        transactionId: t.id,
        date: t.createdAt.toISOString(),
        userId: t.user.username,
        email: t.user.email,
        type: t.type,
        amount: t.amount,
        processingFee: t.processingFee || 0,
        status: t.status,
        paymentMethod: t.paymentMethod,
      })),
    };
  }

  private async getPayoutsData(filters: any) {
    const payouts = await this.prisma.payout.findMany({
      where: {
        createdAt: {
          gte: new Date(filters.dateFrom),
          lte: new Date(filters.dateTo),
        },
      },
      include: {
        creator: { select: { id: true, username: true, email: true } },
      },
      orderBy: { createdAt: 'desc' },
    });

    return {
      items: payouts.map((p) => ({
        payoutId: p.id,
        date: p.createdAt.toISOString(),
        creatorUsername: p.creator.username,
        creatorEmail: p.creator.email,
        amount: p.amount,
        status: p.status,
        method: p.method,
        completedAt: p.completedAt?.toISOString() || 'Pending',
      })),
    };
  }
}
