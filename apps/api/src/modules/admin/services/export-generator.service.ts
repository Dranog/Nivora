import { Injectable, Logger } from '@nestjs/common';
import { S3Service } from '../../integrations/storage/s3.service';
import PDFDocument from 'pdfkit';
import { Parser } from 'json2csv';
import * as XLSX from 'xlsx';

@Injectable()
export class ExportGeneratorService {
  private readonly logger = new Logger(ExportGeneratorService.name);

  constructor(private readonly s3: S3Service) {}

  async generatePDF(data: any, type: string): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({ margin: 50 });
        const chunks: Buffer[] = [];

        doc.on('data', (chunk: any) => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));
        doc.on('error', reject);

        doc.fontSize(24).text('Oliver Platform', { align: 'center' });
        doc.moveDown(0.5);
        doc.fontSize(16).text(`${type.toUpperCase()} Report`, { align: 'center' });
        doc.moveDown(0.5);
        doc.fontSize(10).text(`Generated: ${new Date().toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        })}`, { align: 'center' });

        doc.moveDown(2);
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(1);

        if (data.summary) {
          doc.fontSize(14).text('Financial Summary', { underline: true });
          doc.moveDown(0.5);

          const summaryEntries = Object.entries(data.summary);
          summaryEntries.forEach(([key, value]: [string, any]) => {
            const label = key.split(/(?=[A-Z])/).join(' ').replace(/^\w/, (c) => c.toUpperCase());
            const amount = typeof value === 'number' ? `€${(value / 100).toFixed(2)}` : value;

            doc.fontSize(10).text(`${label}:`, 70, doc.y, { continued: true });
            doc.text(amount, 300, doc.y);
            doc.moveDown(0.5);
          });
        }

        if (data.items && data.items.length > 0) {
          doc.moveDown(1);
          doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
          doc.moveDown(1);

          doc.fontSize(14).text('Detailed Records', { underline: true });
          doc.moveDown(0.5);

          const headers = Object.keys(data.items[0]);
          const colWidth = 500 / headers.length;

          doc.fontSize(9);
          headers.forEach((header, i) => {
            doc.text(
              header.replace(/([A-Z])/g, ' $1').trim(),
              70 + (i * colWidth),
              doc.y,
              { width: colWidth, continued: i < headers.length - 1 }
            );
          });
          doc.moveDown(0.5);
          doc.moveTo(70, doc.y).lineTo(570, doc.y).stroke();
          doc.moveDown(0.5);

          data.items.slice(0, 50).forEach((item: any) => {
            const y = doc.y;
            headers.forEach((header, i) => {
              let value = item[header];
              if (typeof value === 'number' && header.includes('amount')) {
                value = `€${(value / 100).toFixed(2)}`;
              }
              doc.text(
                String(value || '-'),
                70 + (i * colWidth),
                y,
                { width: colWidth - 5, continued: i < headers.length - 1 }
              );
            });
            doc.moveDown(0.5);

            if (doc.y > 700) {
              doc.addPage();
            }
          });

          if (data.items.length > 50) {
            doc.moveDown(1);
            doc.fontSize(8).fillColor('gray').text(
              `Note: Only first 50 records shown. Total records: ${data.items.length}`,
              { align: 'center' }
            );
          }
        }

        doc.fontSize(8).fillColor('gray');
        const pageCount = doc.bufferedPageRange().count;
        for (let i = 0; i < pageCount; i++) {
          doc.switchToPage(i);
          doc.text(
            `Page ${i + 1} of ${pageCount} | Generated by Oliver Admin Panel`,
            50,
            750,
            { align: 'center' }
          );
        }

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  async generateCSV(data: any): Promise<Buffer> {
    try {
      const items = data.items || [];
      if (items.length === 0) {
        throw new Error('No data to export');
      }

      const parser = new Parser();
      const csv = parser.parse(items);
      return Buffer.from(csv, 'utf-8');
    } catch (error) {
      this.logger.error('Error generating CSV', error);
      throw error;
    }
  }

  async generateXLSX(data: any): Promise<Buffer> {
    try {
      const items = data.items || [];
      if (items.length === 0) {
        throw new Error('No data to export');
      }

      const worksheet = XLSX.utils.json_to_sheet(items);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');

      const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const address = XLSX.utils.encode_col(C) + "1";
        if (!worksheet[address]) continue;
        worksheet[address].s = {
          font: { bold: true },
          fill: { fgColor: { rgb: "00B8A9" } },
        };
      }

      return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' }) as Buffer;
    } catch (error) {
      this.logger.error('Error generating XLSX', error);
      throw error;
    }
  }
}
